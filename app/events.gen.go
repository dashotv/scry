// Code generated by github.com/dashotv/golem. DO NOT EDIT.
package app

import (
	"context"
	"fmt"
	"time"

	"github.com/nats-io/nats.go"
	"go.uber.org/zap"

	"github.com/dashotv/fae"
	"github.com/dashotv/mercury"
	runic "github.com/dashotv/runic/client"
	"github.com/dashotv/scry/search"
)

func init() {
	initializers = append(initializers, setupEvents)
	healthchecks["events"] = checkEvents
	starters = append(starters, startEvents)
}

type EventsChannel string
type EventsTopic string

func setupEvents(app *Application) error {
	events, err := NewEvents(app)
	if err != nil {
		return err
	}

	app.Events = events
	return nil
}

func startEvents(ctx context.Context, app *Application) error {
	go app.Events.Start(ctx)
	return nil
}

func checkEvents(app *Application) error {
	switch app.Events.Merc.Status() {
	case nats.CONNECTED:
		return nil
	default:
		return fae.Errorf("nats status: %s", app.Events.Merc.Status())
	}
}

type Events struct {
	App      *Application
	Merc     *mercury.Mercury
	Log      *zap.SugaredLogger
	Episodes chan *EventEpisodes
	Movies   chan *EventMovies
	Runic    chan *runic.Release
	Series   chan *EventSeries
}

func NewEvents(app *Application) (*Events, error) {
	m, err := mercury.New("scry", app.Config.NatsURL)
	if err != nil {
		return nil, err
	}

	e := &Events{
		App:      app,
		Merc:     m,
		Log:      app.Log.Named("events"),
		Episodes: make(chan *EventEpisodes),
		Movies:   make(chan *EventMovies),
		Runic:    make(chan *runic.Release),
		Series:   make(chan *EventSeries),
	}

	if err := e.Merc.Receiver("tower.episodes", e.Episodes); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("tower.movies", e.Movies); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("runic.releases", e.Runic); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("tower.series", e.Series); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *Events) Start(ctx context.Context) error {
	e.Log.Debugf("starting events...")
	// receiver: Episodes
	for i := 0; i < 1; i++ {
		go func() {
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-e.Episodes:
					onEpisodes(e.App, m)
				}
			}
		}()
	}

	// receiver: Movies
	for i := 0; i < 1; i++ {
		go func() {
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-e.Movies:
					onMovies(e.App, m)
				}
			}
		}()
	}

	// receiver: Runic
	for i := 0; i < 10; i++ {
		go func() {
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-e.Runic:
					onRunic(e.App, m)
				}
			}
		}()
	}

	// receiver: Series
	for i := 0; i < 1; i++ {
		go func() {
			for {
				select {
				case <-ctx.Done():
					return
				case m := <-e.Series:
					onSeries(e.App, m)
				}
			}
		}()
	}

	return nil
}

func (e *Events) Send(topic EventsTopic, data any) error {
	f := func() interface{} { return e.doSend(topic, data) }

	err, ok := WithTimeout(f, time.Second*5)
	if !ok {
		e.Log.Errorf("timeout sending: %s", topic)
		return fmt.Errorf("timeout sending: %s", topic)
	}
	if err != nil {
		e.Log.Errorf("sending: %s", err)
		return fae.Wrap(err.(error), "events.send")
	}
	return nil
}

func (e *Events) doSend(topic EventsTopic, data any) error {
	switch topic {
	default:
		e.Log.Warnf("events.send: unknown topic: %s", topic)
	}
	return nil
}

type EventEpisodes struct { // episodes
	Event   string        `bson:"event" json:"event"`
	ID      string        `bson:"id" json:"id"`
	Episode *search.Media `bson:"episode" json:"episode"`
}

type EventMovies struct { // movies
	Event string        `bson:"event" json:"event"`
	ID    string        `bson:"id" json:"id"`
	Movie *search.Media `bson:"movie" json:"movie"`
}

type EventSeries struct { // series
	Event  string        `bson:"event" json:"event"`
	ID     string        `bson:"id" json:"id"`
	Series *search.Media `bson:"series" json:"series"`
}
