// Code generated by github.com/dashotv/golem. DO NOT EDIT.
package app

import (
	"fmt"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/pkg/errors"
	"go.uber.org/zap"

	"github.com/dashotv/mercury"
	"github.com/dashotv/scry/search"
)

func init() {
	initializers = append(initializers, setupEvents)
	healthchecks["events"] = checkEvents
}

type EventsChannel string
type EventsTopic string

func setupEvents(app *Application) error {
	events, err := NewEvents(app)
	if err != nil {
		return err
	}

	app.Events = events
	return nil
}

func checkEvents(app *Application) error {
	switch app.Events.Merc.Status() {
	case nats.CONNECTED:
		return nil
	default:
		return errors.Errorf("nats status: %s", app.Events.Merc.Status())
	}
}

type Events struct {
	App      *Application
	Merc     *mercury.Mercury
	Log      *zap.SugaredLogger
	Movies   chan *EventMovies
	Releases chan *search.Release
	Series   chan *EventSeries
}

func NewEvents(app *Application) (*Events, error) {
	m, err := mercury.New("scry", app.Config.NatsURL)
	if err != nil {
		return nil, err
	}

	e := &Events{
		App:      app,
		Merc:     m,
		Log:      app.Log.Named("events"),
		Movies:   make(chan *EventMovies),
		Releases: make(chan *search.Release),
		Series:   make(chan *EventSeries),
	}

	if err := e.Merc.Receiver("tower.movies", e.Movies); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("tower.index.releases", e.Releases); err != nil {
		return nil, err
	}

	if err := e.Merc.Receiver("tower.series", e.Series); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *Events) Start() error {
	e.Log.Infof("starting events...")
	go func() {
		// wire up receivers
		for {
			select {
			case m := <-e.Movies:
				onMovies(e.App, m)

			case m := <-e.Releases:
				onReleases(e.App, m)

			case m := <-e.Series:
				onSeries(e.App, m)
			}
		}
	}()
	return nil
}

func (e *Events) Send(topic EventsTopic, data any) error {
	f := func() interface{} { return e.doSend(topic, data) }

	err, ok := WithTimeout(f, time.Second*5)
	if !ok {
		e.Log.Errorf("timeout sending: %s", topic)
		return fmt.Errorf("timeout sending: %s", topic)
	}
	if err != nil {
		e.Log.Errorf("sending: %s", err)
		return errors.Wrap(err.(error), "events.send")
	}
	return nil
}

func (e *Events) doSend(topic EventsTopic, data any) error {
	switch topic {
	default:
		e.Log.Warnf("events.send: unknown topic: %s", topic)
	}
	return nil
}

type EventMovies struct { // movies
	Event string        `bson:"event,omitempty" json:"event,omitempty"`
	Id    string        `bson:"id,omitempty" json:"id,omitempty"`
	Movie *search.Media `bson:"movie,omitempty" json:"movie,omitempty"`
}

type EventSeries struct { // series
	Event  string        `bson:"event,omitempty" json:"event,omitempty"`
	Id     string        `bson:"id,omitempty" json:"id,omitempty"`
	Series *search.Media `bson:"series,omitempty" json:"series,omitempty"`
}
